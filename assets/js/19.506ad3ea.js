(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{351:function(a,r,c){"use strict";c.r(r);var s=c(3),t=Object(s.a)({},(function(){var a=this,r=a.$createElement,c=a._self._c||r;return c("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[c("p",[a._v("最近日常升级了一下Arch Linux，但是发现系统开机后进不了图形界面，sddm启动不起来。经过一番搜索确定是"),c("code",[a._v("sddm 0.16.0-1")]),a._v("的问题，于是对sddm进行了降级操作。接下来就让我来讲述一下在Arch Linux下面对软件包进行降级的操作。")]),a._v(" "),c("h2",{attrs:{id:"pacman"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#pacman"}},[a._v("#")]),a._v(" pacman")]),a._v(" "),c("p",[a._v("相信了解过Arch Linux的都知道pacman。pacman 是一个Arch Linux的包管理软件，是Arch Linux用户体验的重要组成部分。我记得有这么一句形容Arch Linux的话")]),a._v(" "),c("p",[a._v("Linux, with a nice package manager.")]),a._v(" "),c("p",[a._v("这一方面说明Arch Linux是一个非常简洁、轻量的发行版，一方面也说明了pacman对整个用户体验的重要程度。")]),a._v(" "),c("p",[a._v("包管理在许多Linux发行版中都有，譬如说debian的apt，这也是Linux比较有特点的地方。许多常用的软件，都可以在包管理中找到并下载安装，而且软件的升级和卸载都是由包管理来完成的。")]),a._v(" "),c("h2",{attrs:{id:"为何降级"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#为何降级"}},[a._v("#")]),a._v(" 为何降级")]),a._v(" "),c("p",[a._v("Arch Linux是一个滚动更新（rolling update）的发行版，所以我们习惯把包升级、系统升级叫为“滚一下”。这就是说Arch Linux里面的软件基本上是直接从开发者（上游，upstream）到用户的，而Arch Linux的包管理者只是把上游的软件打包一下。")]),a._v(" "),c("p",[a._v("这样一种滚动更新的方式可以让用户及时获得最新的软件，但这也意味着带来软件最新而还未被开发者修复的bugs，即所谓的upsteram bugs。upstream bugs不是Arch Linux的问题，所以Arch Linux官方并不会对这样的bug进行修复。一般来说，这没有多大问题。但是如果有时候软件出现了比较严重的bug，就会让软件无法正常工作，甚至是使整个系统进入一种瘫痪的不可用的状态。")]),a._v(" "),c("p",[a._v("然而，生活还要继续的呀，系统可不能崩掉啊，不然怎么继续写代码啊。怎么能让一个upstream bug毁掉我们的系统呢。"),c("s",[a._v("这时候我们就要重装。")])]),a._v(" "),c("p",[a._v("其实重装也不是不行，但是重装是相对来说比较麻烦的，搞不好还要折腾一下。其实我们可以利用pacman来对软件就行降级（downgrade），安装相对旧一点的版本，来规避一些严重的upstream bugs。")]),a._v(" "),c("h2",{attrs:{id:"如何降级"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#如何降级"}},[a._v("#")]),a._v(" 如何降级")]),a._v(" "),c("p",[a._v("Arch Linux的wiki上有详细的"),c("a",{attrs:{href:"https://wiki.archlinux.org/index.php/downgrading_packages",target:"_blank",rel:"noopener noreferrer"}},[a._v("包降级指南"),c("OutboundLink")],1),a._v("。建议"),c("strong",[a._v("严格遵循")]),a._v("wiki上的操作指引。以下只是笔者尝试过的两种办法。")]),a._v(" "),c("h3",{attrs:{id:"用pacman的cache降级"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#用pacman的cache降级"}},[a._v("#")]),a._v(" 用pacman的cache降级")]),a._v(" "),c("p",[a._v("pacman在安装、升级包的时候都会将下载来的包缓存一下，这对回滚心切的用户来说简直就是救命稻草。pacman缓存的包放在"),c("code",[a._v("/var/cache/pacman/pkg/")]),a._v("下，我们可以对目录进行搜索，看一下pacman有没有缓存我们要降级的软件的旧包。譬如说，我"),c("code",[a._v("sddm 0.16.0-1")]),a._v("炸了，然后我在缓存目录下找到了前一次更新的包"),c("code",[a._v("sddm-0.15.0-2-x86_64.pkg.tar.xz")]),a._v("。找到了这个旧的包，说明你可以比较轻松的解决降级这个问题了（如果包依赖没有问题的话）。这时候，我们就可以执行一下指令（以sddm为例的话）")]),a._v(" "),c("div",{staticClass:"language-shell extra-class"},[c("pre",{pre:!0,attrs:{class:"language-shell"}},[c("code",[c("span",{pre:!0,attrs:{class:"token function"}},[a._v("sudo")]),a._v(" pacman -U /var/cache/pacman/pkg/sddm-0.15.0-2-x86_64.pkg.tar.xz\n")])])]),c("p",[a._v("pacman会处理相应的包依赖关系，但如果降级会导致一些版本冲突的问题，那可能还要继续对其他相关的包进行降级操作。")]),a._v(" "),c("h3",{attrs:{id:"aur-降级"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#aur-降级"}},[a._v("#")]),a._v(" AUR 降级")]),a._v(" "),c("p",[a._v("过了一两天后，我发现小黑龙的"),c("code",[a._v("sddm")]),a._v("也炸了。于是赶紧让他降级。他在经过一段时间与bug的斗争之后，选择了降级。然而他安装的"),c("code",[a._v("sddm")]),a._v("并不是官方源里的，而是AUR里面"),c("code",[a._v("sddm-git")]),a._v("。关于AUR的在这里就不多说了。小黑龙并不能回滚到pacman缓存的包，因为这与他安装的"),c("code",[a._v("sddm-git")]),a._v("冲突。于是只能采取一些更为复杂的办法。我们先将PKGBUILD里面的source改了一下，直接把"),c("code",[a._v("sddm")]),a._v("的GitHub仓库从source里删掉了，然后把src里面的git仓库checkout到了前一个版本，这样就可以顺利的对老版本"),c("code",[a._v("sddm-git")]),a._v("打包了。之后的操作就很简单了，用pacman来安装打好的包。")]),a._v(" "),c("p",[a._v("虽然说小黑龙确实是成功回滚了，但是好像他回滚的那一个版本仍然是有bug的。于是他最后卸载了"),c("code",[a._v("sddm-git")]),a._v("，然后装上了"),c("code",[a._v("sddm 0.15.0-2")]),a._v("。")]),a._v(" "),c("hr"),a._v(" "),c("p",[a._v("虽然说Arch Linux时常会带来一些upstream bugs，但是其实解决起来也并不困难。而且Arch Linux其实是比较稳定的，并没有那么容易炸。")])])}),[],!1,null,null,null);r.default=t.exports}}]);